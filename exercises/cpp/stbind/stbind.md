# Статический полиморфизм

## SB-010-PRINTDELIM

У вас уже есть класс `IntVector` с предыдущих тем. Напишите еще класс `IntFixedVector`, не реаллоцирующий подлежащий массив, но более ничем не отличающийся от класса `IntVector`. Напишите модуль, реализующий полиморфную функцию `void print(v, delim)`, где `v` - это вектор (объект типа `IntVector` или типа `IntFixedVector`), а `delim` - это строка (можно использовать тип `std::string` или ваш тип `String` из упражнений к предыдущим темам. Эта полиморфная функция распечатывает на стандартный поток вывода элементы вектора `v` от начала к концу, разделяя каждый элемент строкой `delim`. Классы `IntVector` и `IntFixedVector` ничего не знают о существовании друг друга. Можно ли будет в дальнейшем добавить поддержку еще одного типа векторов? Если да, то как это сделать?


## SB-040-TESTS

Модульные тесты - это важная часть разработки качественного ПО. Обычно этих тестов много и их нужно выполнять часто и быстро. В идеале, их следует запускать при каждой успешной компиляции. Сначала компилятор проверит программу на своем наборе ошибок - он общий для всех программ - а потом тесты проверят, правильно ли программа решает поставленную задачу.

Каждый тест должен проверять какой-то один аспект решения задачи на определенных входных данных. Тогда провалившийся тест четко укажет на ошибку в программе. Это удобство приводит к большому числу тестов. Как минимум, их объединяют в группы (_тестовые наборы_), по-английски _test suite_.

Все тесты должны быть независимы друг от друга, их поведение должно быть повторяемо, они должны выполняться быстро. Это позволяет искать ошибку, анализируя только провалившиеся тесты, т.е. не анализируя (не отлаживая) тесты, выполнявшиеся ранее. Это очень сильно сокращает время на отладку программы по провалившемуся тесту. Плюс, это дает свободу инструменту тестирования самому выбрать порядок запуска тестов.

Чтобы тесту быть независимым от других тестов, но при этом чтобы тест мог использовать окружение и оказывать на него побочный эффект, он должен вначале настроить все окружение под себя, затем выполнить проверку и, наконец, "прибраться" за собой. То есть выполнение теста может состоять из нескольких этапов.

Тестовый набор имеет схожие черты с тестом: и тот, и другой можно _выполнить_, и тот, и другой может завершиться успешно или провалиться.

Из всего вышеперечисленного делают такой вывод: тест можно оформить в виде класса, отдельные этапы разместить в отдельных методах (даже имена методов почти везде одинаковые: `setUp` - метод установки окружения, `test` - метод тестирования, `tearDown` - метод восстановления окружения на момент до запуска теста). В классе может быть несколько методов тестирования - тогда это, фактически, сокращенная запись нескольких классов с одинаковыми методами `setUp` и `tearDown`. Только методам тестирования нужно придумать имена различные друг от друга. Все-все методы обладают пустым списком формальных аргументов.

Класс для тестового набора связан с набором классов для тестов. Именно классов, а не объектов! Это так, потому что если в классе-тесте несколько методов тестирования, то для запуска каждого метода тестирования нужно создавать отдельный объект класса-теста (иначе тесты в этом классе-тесте не будут независимыми). Этот объект (поля объекта) будет наполняться нужными данными в методе `setUp` и очищаться в методе `tearDown`. Не смотря на код класса-теста, нельзя сказать, сколько потребуется объектов этого класса. Поэтому класс для тестового набора связывается не с объектами классов-тестов, а с самими классами-тестами.

Ваша задача - реализовать полиморфную функцию `void run(t)`, где `t` - это любой класс, имеющий черты теста.
